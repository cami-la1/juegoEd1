//---------------------------------------------------------------------------

#pragma hdrstop

#include "matrizSC.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
   // Constructor
MatrizSC::MatrizSC() {
    df = 0;
    dc = 0;
    repe = 0;
    nt = 0;
}

// Métodos
void MatrizSC::dimensionar(int nf, int nc) {
    df = nf;
    dc = nc;
}

int MatrizSC::dimension_fila() {
    return df;
}
void desplazar() {
    int i = 0;
    while (i < nt) {
        if (VD[i] == repe) {
            for (int j = i; j < nt - 1; j++) {
                VD[j] = VD[j + 1];
                Vf[j] = Vf[j + 1];
                VC[j] = VC[j + 1];
            }
            nt--;
        } else {
            i++;
        }
    }
}

int MatrizSC::dimension_columna() {
    return dc;
}void MatrizSC::poner(int f, int c, int e) {
    // Buscar en vector vf,vc los valores f y c y retornar indice
    int Lug = -1;
    for (int i = 0; i < nt; i++) {
        if (Vf[i] == f && VC[i] == c) {
            Lug = i;
            break;
        }
    }

    if (Lug != -1) {
        // Si encontramos una coincidencia, actualizamos el valor
        VD[Lug] = e;
        if (VD[Lug] == repe) {
            desplazar();
        }
    } else if (nt < MAX) {
        // Si no encontramos una coincidencia y hay espacio, añadimos el nuevo valor
        VD[nt] = e;
        Vf[nt] = f;
        VC[nt] = c;
        nt++;
    } else {
        // Si no hay espacio, mostramos un error
        std::cerr << "Error: No hay espacio en la matriz." << std::endl;
    }
}

int MatrizSC::Elemento(int f, int c) {
	if (f >= 1 && f <= df && c >= 1 && c <= dc) {
		// Buscar f,c en vectores vc,vf y retornar lugar
		int Lug = -1;
		for (int i = 0; i < nt; i++) {
			if (Vf[i] == f && VC[i] == c) {
                Lug = i;
                break;
            }
        }
        if (Lug != -1) {
            return VD[Lug];
        } else {
            return repe;
        }
    } else {
        // Error fuera de rango indices
        std::cerr << "Error: Los índices están fuera de rango." << std::endl;
        return -1;
    }
}
  void MatrizSC:: Definir_valor_repetido(int valor) {
    repe = valor;
    // este algoritmo no considera si este método es llamado en tiempo de ejecución
    // Para manejar esto, podrías necesitar reevaluar los elementos en la matriz y realizar ajustes según sea necesario.
}
void MatrizSC::imprimir(TColor FormColor, TCanvas *Canvas) {
    // Obtén las dimensiones del Canvas
    int canvasWidth = Canvas->ClipRect.Width();
    int canvasHeight = Canvas->ClipRect.Height();

    // Calcula el tamaño de cada celda de la matriz en el Canvas
    int cellWidth = 40;
    int cellHeight = 30;

    // Calcula el desplazamiento para centrar la matriz en el Canvas
    int offsetX = (canvasWidth - dc * cellWidth) / 2;
    int offsetY = (canvasHeight - df * cellHeight) / 2;

    // Asegúrate de que el Canvas esté limpio
    Canvas->Brush->Color = FormColor;
    Canvas->FillRect(TRect(0, 0, canvasWidth, canvasHeight));

    // Cambia el color del pincel para dibujar la matriz
    Canvas->Pen->Color = clBlack; // Solo cambia el color del lápiz, no el del pincel

    // Recorre la matriz y dibuja cada celda
    for (int i = 1; i <= df; i++) {
        for (int j = 1; j <= dc; j++) {
            // Calcula la posición de la celda
            int x = offsetX + (j - 1) * cellWidth;
            int y = offsetY + (i - 1) * cellHeight;

            // Dibuja el recuadro de la celda
            Canvas->Rectangle(x, y, x + cellWidth, y + cellHeight);

            // Dibuja el valor de la celda
            int valor = Elemento(i, j);
            Canvas->Font->Color = clBlack; // Cambia el color del texto a negro
            Canvas->TextOutW(x + cellWidth / 2, y -10+ cellHeight / 2, IntToStr(valor));
        }
    }
}

